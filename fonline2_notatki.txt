FOClient::AddAction
	adres funkcji: FOnline 2.exe+878D1
	przyjmuje FOClient*
	_thiscall
	
FOClient::AddActioBack
	adres: +879B1
	przyjmuje FOClient*
	_thiscall
	
FOClient::SetAction
	adres: fonline 2.exe+8ADA1
	przyjmuje FOClient*
	_thiscall
	
drugie FOClient::SetAction
	adres: fonline 2.exe+8DDE1
	wywołuje powyższe
	przyjmuje: FOClient*, kilka argumentów (opis niżej)
	
FOClient::GameLMouseDown
	adres: fonline 2.exe+D5DD1
	wywołuje SetAction w kilku różnych kontekstach
	przyjmuje FOClient*
	_thiscall
	
FOClient::AimLMouseUp
	wywołuje SetAction
	przyjmuje FOClient*
	_thiscall
	
FOClient::ParseMouse
	wywołuje GameLMouseDown w fonline 2.exe+97f02
	wywołuje AimLMouseUp
	adres fonline 2.exe+972B1
	przyjmuje FOClient*
	_thiscall
	
FOClient::MainLoop
	fonline 2.exe+A7F71
	wywołuje ParseMouse w fonline 2.exe+a822c = 004A822C
	
FOClient::IsAction
	fonline 2.exe+72111
	przyjmuje FOClient* + jeden argument na stosie (co?)
	_thiscall
	powinien zwrócić: czy nie był w trakcie ruchu?
	
Timer::FastTick
	zwraca czas
	_stdcall (chyba)
	brak argumentów
	
main
	+111741
	wywołuje MainLoop w +111B7F
	
FOnline 2.exe+111B17 - 68 50B80000           - push 0000B850 { 47184 }
FOnline 2.exe+111B1C - E8 58131800           - call "FOnline 2.operator new"

FOClient ma 47184 bajty?

w +79E2F ustawione "pChosen"

FOnline 2.stlp_std::vector<FOClient::ActionEvent,stlp_std::allocator<FOClient::ActionEvent> >::_M_insert_overflow - 55                    - push ebp
	FOnline 2.exe+79D01
	+87999 wywołanie w AddAction
	dostaje FOClient+934 ("Chosen")

zmienić na losowe stringi przed uruchomieniem, żeby multi-log:
	fonline_instance address
	fonline 2.exe+3433B4 = 7433b4

	_fosync_ address
	fonline 2.exe+33BCDC = 73bcdc

aimed attack w funkcji AimLMouseUp

FOClient + 240: typ wybranej akcji (myszka)
	3 = atak
	1 = ruch
	0 = zwykły wskaźnik
	6 = rączka w inventory
	4 = użycie skilla
	5 pojawia się na chwilę zaraz po użyciu skilla?
brakuje: use on (to samo co skill?), otwarta rączka (gdy np. ścinamy drzewo)

FOClient + 244: poprzedni typ wybranej akcji?. Po co?

argumenty przekazywane do SetAction na stosie, od lewej do prawej:
1. typ akcji
	1 = ACTION_MOVE
	6 = atak bez aima (??) (może być autoaim)
	10 = skill
2. zależnie od typu akcji:
	jeśli ruch, to wsp. 1
	jeśli atak, to:
		mov edx, [ecx+10ac] hand?
		mov ecx, [edx]
		push ecx
		jakiś identyfikator (przedmiotu? itemId?)
	jeśli skill, to jaki skill
3. zależnie od typu akcji:
	jeśli ruch, to wsp. 2
	jeśli atak, to:
		esi = FOClient
		mov ecx, [esi+b7d8] Critter gracz
		mov edx, [ecx+10ac] hand?
		mov ecx, [edx+4] item?
		movzx eax, word ptr [ecx]
		push eax
		
		itemID? (ale coś innego niż to wyżej)
	jeśli skill, to critter id? to samo 5. w przypadku ataku
4. zależnie od typu akcji:
	jeśli ruch, to 1 = bieg, 0 = chód
	jeśli atak, to zawsze 2
	jeśli skill, to zawsze 0?
5. zależnie od typu akcji:
	jeśli ruch, to zawsze 0
	jeśli atak:
		np. 10c90. critter id?
		call HexManager::GetCritterPixel - zapisuje wynik w eax
			ten wynik wskazuje na critter?
			zmienia się przy innych celach
		mov eax,[eax]
			jakiś critter ID?
			też się zmienia
		push eax
		jeszcze jest GetSmthPixel...
	jeśli skill, to zawsze 0?
6.
	jeśli ruch, to czy nie był już w trakcie ruchu
	jeśli skill, to zawsze 0?
	jeśli atak:
		w zwykłym trybie 0 - single, 1 - burst, nawet jak autoaim
			mov edx, [ecx+10ac] hand?
			movzx ecx, byte ptr [edx+30] attack mode
			push ecx
		w trybie celowania - zależy od celu. 1 BAJT
			torso 0x40
			groin 0x80
			left arm 0x20
			left leg 0x60
			right leg 0x50
			right arm 0x30
			eyes 0x70
			head 0x10
		tryb celowania to inny przypadek
		mov ecx, [esi+b7d8]
			esi = FOClient
		mov edx, [ecx+10ac]
		movzx ecx,byte ptr [edx+30]
		push ecx
7.
	jeśli ruch, to czas
	jeśli skill, to zawsze 0?
	jeśli atak, to zawsze 0
	
HexManager::GetSmthPixel
	_thiscall
	wywoływane cały czas, m. in. w GameLMouseDown w różnych kontekstach, przed wywołaniem SetAction
	wyniki zwraca przez referencję.
argumenty przekazywane do HexManager::GetSmthPixel od lewej do prawej:
1. FOClient* + 20 = HexManager*
2. mouse x
3. mouse y
4. referencja dla wsk. do przedmiotu (gdyby pod pikselem nie było crittera)
5. referencja dla wsk. do crittera

HexManager::GetCritter
	adres +800c0
	_thiscall
	wywoływane np. w CrittersProcess przy rozpoczęciu akcji
	zwraca strukturę Critter
	jeden argument: id crittera
	
	crittery są trzymane w uporządkowanej według id liście podwójnie łączonej
	szukanie zaczyna się ze środka listy, HexManager + 10C
	jest jeszcze drugi wskaźnik w HexManager + 110, niby początek listy...
	w algorytmie dzieją się dziwne rzeczy.


FOClient:
	w 0x20 HexManager
	w 0x23c czy menu/WM/enco itd.
		menu = 1
		enco = 5
		WM = 6
		ładowanie = 7
	w 0xb7d8 Critter* gracza (a może to jest w HexManager?)
	
HexManager:
	w 0x120 critterId gracza (może być to pamięć FOClient, ale raczej nie)
	
ItemManager: co to jest?
ItemManager::GetProtoItem
	_thiscall
	adres +10d1b0
	przyjmuje jeden argument: identyfikator przedmiotu? przekazywany potem do SetAction
	co to jest ProtoItem?

FOClient::SScriptFunc::Global_DrawText
	_cdecl
	fonline 2.exe+763e0
	wymaga FOClient::SpritesCanDraw == 1
	ustawione w FOClient::DrawIfaceLayer (adres +68E90):
		mov byte ptr ["FOnline 2.FOClient::SpritesCanDraw"],01
		call "FOnline 2.Script::SetArgUInt"
		add esp,04
		call "FOnline 2.Script::RunPrepared"
		mov byte ptr ["FOnline 2.FOClient::SpritesCanDraw"],00

	argumenty:
		1. tekst
			może w nim wystąpić specyfikacja koloru: "|liczba tekst"

			użycie argumentu w funkcji:
			mov eax,[ebp+8]
			mov ecx,[eax+18]
			push ecx
			ecx w tym momencie wskazuje na tekst do wypisania.
			w wielu przypadkach ecx = eax+4 dla krótkich stringów
			std::string i Short String Optimization?
			ale tak jest też w przypadku "Registration" - dł. 12, za dużo na SSO
			może implementacja MSVC pozwala na dłuższe stringi...
			chyba tak jest: dla stringa "Hub and San Francisco..." ecx leży w zupełnie innym miejscu.
		2. pozycja x
		3. pozycja y
		4. szerokość
		5. wysokość
		6. specyfikacja koloru np. 0xff00aa00, 0xff8f6f0, 0xffababab, 0xffffffff
			w tekście też może wystąpić specyfikacja koloru (w formacie dziesiętnym), która ma pierwszeństwo
		7. czcionka
			0xFFADADB9 - kolor szary
			0xFF00AA00 - zielony używany w wielu miejscach
		8. ciąg flag bitowych
			4 = 3. bit wyśrodkowanie w poziomie
			8 = 4. bit wyśrodkowanie w pionie
			16 = 5. bit do prawej, wyśrodkowanie ma pierwszeństwo
			32 = 6. bit do dołu, wyśrodkowanie ma pierwszeństwo
			512 = 9. bit obramowanie

			np. "First Aid:" 560 = 100110000 = 512 + 32 + 16
			"Aim: Eyes" 12 = 8 + 4
			nick: 548 = 512 + 32 + 4

		przykłady: (2. 4. 5. 3. 6. 8. 7. 1.)
			74 128 25 375 0xff00aa00 4 7 Registration
			74 128 25 405 0xff00aa00 4 7 Options
			0 800 20 40 0xff00c800 524 5 "Hub and NCR..."
			0 800 20 60 0xff00c800 524 5 "Convoy transport..."